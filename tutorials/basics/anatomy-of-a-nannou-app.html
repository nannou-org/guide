<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Basics - Anatomy of a Nannou App - The Nannou Guide</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A one-stop shop for Nannou Knowledge!">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../welcome.html">Welcome!</a></li><li class="chapter-item expanded "><a href="../../why_nannou.html"><strong aria-hidden="true">1.</strong> Why Nannou?</a></li><li class="chapter-item expanded "><a href="../../getting_started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../getting_started/platform-specific_setup.html"><strong aria-hidden="true">2.1.</strong> Platform-specific Setup</a></li><li class="chapter-item expanded "><a href="../../getting_started/installing_rust.html"><strong aria-hidden="true">2.2.</strong> Installing Rust</a></li><li class="chapter-item expanded "><a href="../../getting_started/editor_setup.html"><strong aria-hidden="true">2.3.</strong> Editor Setup</a></li><li class="chapter-item expanded "><a href="../../getting_started/running_examples.html"><strong aria-hidden="true">2.4.</strong> Running Examples</a></li><li class="chapter-item expanded "><a href="../../getting_started/create_a_project.html"><strong aria-hidden="true">2.5.</strong> Create A Project</a></li><li class="chapter-item expanded "><a href="../../getting_started/updating.html"><strong aria-hidden="true">2.6.</strong> Updating Nannou and Rust</a></li></ol></li><li class="chapter-item expanded "><a href="../../tutorials.html"><strong aria-hidden="true">3.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../tutorials/basics/draw-a-sketch.html"><strong aria-hidden="true">3.1.</strong> Basics - Drawing a Sketch</a></li><li class="chapter-item expanded "><a href="../../tutorials/basics/anatomy-of-a-nannou-app.html" class="active"><strong aria-hidden="true">3.2.</strong> Basics - Anatomy of a Nannou App</a></li><li class="chapter-item expanded "><a href="../../tutorials/basics/drawing-2d-shapes.html"><strong aria-hidden="true">3.3.</strong> Basics - Drawing 2D Shapes</a></li></ol></li><li class="chapter-item expanded "><a href="../../developer_reference.html"><strong aria-hidden="true">4.</strong> Developer Reference</a></li><li class="chapter-item expanded "><a href="../../api_reference.html"><strong aria-hidden="true">5.</strong> API Reference</a></li><li class="chapter-item expanded "><a href="../../showcases.html"><strong aria-hidden="true">6.</strong> Showcases</a></li><li class="chapter-item expanded affix "><a href="../../contributors.html">Contributors</a></li><li class="chapter-item expanded affix "><a href="../../code_of_conduct.html">Code of Conduct</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Nannou Guide</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#anatomy-of-a-nannou-app" id="anatomy-of-a-nannou-app">Anatomy of a Nannou App</a></h1>
<p><strong>Tutorial Info</strong></p>
<ul>
<li>Author: tpltnt, mitchmindtree</li>
<li>Required Knowledge: <a href="/getting_started.html">Getting Started</a></li>
<li>Reading Time: 10 minutes</li>
</ul>
<hr />
<p><strong>Nannou is a framework for creative coding in Rust.</strong> A framework can be
thought of as a collection of building blocks to help accomplish a goal.</p>
<p>If romance stories were frameworks, then you might have the protagonist, their
love interest, some struggles, and a happy ending as the building blocks. All of
these need to be fleshed out by the author, but using clichés help to tell a
story without having to introduce everyone and everything in excruciating
detail. If the author wants to tell a horror story, then the clichés of a
romance story aren't very helpful.</p>
<p>In the same way you can use nannou to create programs for artistic expression,
but you might find it hard to build an office suite. So let's take a look at the
building blocks for creative coding together.</p>
<p>Here's an example of a bare-bones nannou app that opens an empty window:</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">extern crate nannou;
</span><span class="boring">
</span>use nannou::prelude::*;

struct Model {}

fn main() {
    nannou::app(model)
        .event(event)
        .simple_window(view)
        .run();
}

fn model(_app: &amp;App) -&gt; Model {
    Model {}
}

fn event(_app: &amp;App, _model: &amp;mut Model, _event: Event) {
}

fn view(_app: &amp;App, _model: &amp;Model, _frame: Frame) {
}
</code></pre></pre>
<p>We will start from the top!</p>
<h2><a class="header" href="#import-common-items" id="import-common-items">Import Common Items</a></h2>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#![allow(unused_imports)]
</span><span class="boring">extern crate nannou;
</span>use nannou::prelude::*;
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>This line imports all of the commonly used items from nannou into scope. These
include items such as <code>App</code>, <code>Frame</code>, and many more that we will learn about
over time. To see the full list of items re-exported by the prelude, see
<a href="https://docs.rs/nannou/latest/nannou/prelude/index.html">here</a>.</p>
<blockquote>
<p>Note: Unlike some other languages, Rust does not automatically include
everything from the libraries added to the project. This approach results in
very clean namespaces and avoids conflicts between different items from
different crates. That said, it also means we need to manually import every
item we <em>do</em> want to use into scope. By providing a prelude nannou makes it a
little easier to access all of the commonly used items.</p>
</blockquote>
<h2><a class="header" href="#model---our-app-state" id="model---our-app-state"><strong>Model</strong> - Our app state</a></h2>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span>struct Model {}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>The <strong>Model</strong> is where we define the state of our application. We can think of
the model as the representation of our program at any point in time. Throughout
the life of our program, we can update the model as certain events occur such as
mouse presses, key presses or timed updates. We can then present the model using
some kind of output, e.g. by drawing to the screen or outputting to a laser. We
will look at these input and output events in more detail in another tutorial!
Our example is as simple as possible, and we have no state to track. Thus our
model can stay empty.</p>
<blockquote>
<p>Note: A <code>struct</code> describes a set of data. Our struct has no fields and thus is
empty. There is no state information to be tracked in this example.</p>
</blockquote>
<h2><a class="header" href="#main---where-rust-programs-begin-and-end" id="main---where-rust-programs-begin-and-end"><strong>main</strong> - Where Rust programs begin and end</a></h2>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">extern crate nannou;
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model {}
</span>fn main() {
    nannou::app(model)
        .event(event)
        .simple_window(view)
        .run();
}
<span class="boring">fn model(_app: &amp;App) -&gt; Model {
</span><span class="boring">    Model {}
</span><span class="boring">}
</span><span class="boring">fn event(_app: &amp;App, _model: &amp;mut Model, _event: Event) {
</span><span class="boring">}
</span><span class="boring">fn view(_app: &amp;App, _model: &amp;Model, _frame: Frame) {
</span><span class="boring">}
</span></code></pre></pre>
<p>All Rust programs begin executing at the start of the <code>main</code> function and end
when the <code>main</code> function ends. In most nannou programs, the main function is
quite small. In short, we build a description of our app and then run it!</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">extern crate nannou;
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model {}
</span><span class="boring">fn main() {
</span>    nannou::app(model)       // Start building the app and specify our `model`
        .event(event)        // Specify that we want to handle app events with `event`
        .simple_window(view) // Request a simple window to which we'll draw with `view`
        .run();              // Run it!
<span class="boring">}
</span><span class="boring">fn model(_app: &amp;App) -&gt; Model {
</span><span class="boring">    Model {}
</span><span class="boring">}
</span><span class="boring">fn event(_app: &amp;App, _model: &amp;mut Model, _event: Event) {
</span><span class="boring">}
</span><span class="boring">fn view(_app: &amp;App, _model: &amp;Model, _frame: Frame) {
</span><span class="boring">}
</span></code></pre></pre>
<p>We will describe what these <strong>model</strong>, <strong>event</strong> and <strong>view</strong> functions do
below!</p>
<blockquote>
<p>Note: In this app building process we get a hint at the fundamental design
archetype of nannou apps. The approach is roughly based on the
<a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">Model-View-Controller (MVC)
pattern</a>,
though equally inspired by <a href="https://en.wikipedia.org/wiki/Functional_reactive_programming">Functional Reactive Programming
(FRP)</a>.</p>
<p>In general, these paradigms split a program into:</p>
<ul>
<li>a <strong>model</strong> describing the internal state</li>
<li>a <strong>view</strong> describing how to present the model and</li>
<li>a <strong>controller</strong> describing how to update the model on certain events.</li>
</ul>
<p>If you zoom out a bit you can think of the computer as a model, the screen as
a view (the audio output could also be thought of as a view), and the keyboard
(or mouse) as the controller. A user looks at the view and can change the
state of the model using the controller. If a program does not require user
input, the controller might use an algorithm based on time or some other
application event to modify the model.</p>
</blockquote>
<h2><a class="header" href="#model---initialise-our-model" id="model---initialise-our-model"><strong>model</strong> - initialise our Model</a></h2>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">extern crate nannou;
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model {}
</span>fn model(_app: &amp;App) -&gt; Model {
    Model {}
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>The <code>model</code> function is run once at the beginning of the nannou app and produces
a fresh, new instance of the <strong>Model</strong> that we declared previously, AKA the app
state. This can be thought of as the &quot;setup&quot; stage of our application. Here, we
might do things like create some windows, create a GUI, load some images or
anything else that we want to happen once at the beginning of our program. We
will learn how to do all of these things in future tutorials, but for now we
will just return an instance of our empty <strong>Model</strong>.</p>
<blockquote>
<p>Note: To assist with the creation of windows, GUIs, audio streams and other
kinds of I/O, access to the <strong>App</strong> is provided as an <em>input</em> to the function.
The <strong>App</strong> type can be thought of as a helper type that wraps up the finicky
details of the application (such as establishing event loops, spawning I/O
streams, etc) and provides an easy to use, high-level API on top. Providing
access to the <strong>App</strong> via a function's first argument is a common practice
throughout nannou's API.</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">extern crate nannou;
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model {}
</span>//                ----- Access to the `App` passed as an input to the function.
//               /
//              v
fn model(_app: &amp;App) -&gt; Model {
    Model {}
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>You can learn more about what the <strong>App</strong> is responsible for and capable of
<a href="https://docs.rs/nannou/latest/nannou/app/struct.App.html">here</a>.</p>
</blockquote>
<h2><a class="header" href="#event---updating-the-model-on-app-events" id="event---updating-the-model-on-app-events"><strong>event</strong> - updating the Model on app events</a></h2>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">extern crate nannou;
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model {}
</span>fn event(_app: &amp;App, _model: &amp;mut Model, _event: Event) {
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>The <strong>event</strong> function is some code that will run every time some kind of app
event occurs. There are many different kinds of app events including mouse and
keyboard presses, window resizes, timed updates and many more. Each of these are
events during which we may wish to update our <strong>Model</strong> in some way. For
example, we may wish to turn a camera when a mouse is moved, begin drawing a
shape when a button is pressed, or step forward an animation on timed updates.</p>
<p>All of these events are described within the <strong>Event</strong> type. One way to
distinguish between which event is currently occurring is to <a href="https://doc.rust-lang.org/book/ch06-02-match.html">&quot;pattern
match&quot;</a> on the event and
handle only those events that we care about, ignoring all the others. A simpler
approach is to not register an <strong>event</strong> function while building the app at all,
and instead only register more specific functions for those events that we care
about.</p>
<p>For example, if instead of handling <em>all</em> events we only want to handle timed
updates (an event that by default occurs 60 times per second) we could change
our app building code to this:</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">extern crate nannou;
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model {}
</span>fn main() {
    nannou::app(model)
        .update(update) // rather than `.event(event)`, now we only subscribe to updates
        .simple_window(view)
        .run();
}
<span class="boring">fn model(_app: &amp;App) -&gt; Model {
</span><span class="boring">    Model {}
</span><span class="boring">}
</span><span class="boring">fn update(_app: &amp;App, _model: &amp;mut Model, _update: Update) {
</span><span class="boring">}
</span><span class="boring">fn view(_app: &amp;App, _model: &amp;Model, _frame: Frame) {
</span><span class="boring">}
</span></code></pre></pre>
<p>And remove our <code>event</code> function in favour of an <code>update</code> function:</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">extern crate nannou;
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model {}
</span>fn update(_app: &amp;App, _model: &amp;mut Model, _update: Update) {
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>Now, our new <strong>update</strong> function will only run each time a timed update
occurs.</p>
<blockquote>
<p>Note: Nannou provides a whole suite of different events that may be registered
while building an app or window in this way. See the <a href="https://github.com/nannou-org/nannou/blob/master/examples/nannou_basics/all_functions.rs">all_functions.rs
example</a>
for a demonstration of most of the different kinds of events that are
available.</p>
</blockquote>
<h2><a class="header" href="#view---presenting-the-model-to-a-window" id="view---presenting-the-model-to-a-window"><strong>view</strong> - presenting the Model to a window</a></h2>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">extern crate nannou;
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model {}
</span>fn view(_app: &amp;App, _model: &amp;Model, _frame: Frame) {
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>Finally, the <strong>view</strong> allows us to present the state of the model to a window by
drawing to its <strong>Frame</strong> and returning the frame at the end. Here we can change
the background colour, use the <strong>Draw</strong> API to draw a scene, draw a GUI to the
window or even use the wgpu API to draw to the frame using our own textures and
render passes. All of this will be covered by future tutorials.</p>
<h2><a class="header" href="#concluding-remarks" id="concluding-remarks">Concluding Remarks</a></h2>
<p>Hopefully this has given you a rough idea of how nannou apps work! Do not stress
if some of the syntax looks confusing or some of the specifics still seem
unclear - we will aim to cover these and more in future tutorials :)</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../tutorials/basics/draw-a-sketch.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../../tutorials/basics/drawing-2d-shapes.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../../tutorials/basics/draw-a-sketch.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../../tutorials/basics/drawing-2d-shapes.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
