<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Nannou Guide</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A one-stop shop for Nannou Knowledge!">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="welcome.html">Welcome!</a></li><li class="chapter-item expanded "><a href="why_nannou.html"><strong aria-hidden="true">1.</strong> Why Nannou?</a></li><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting_started/platform-specific_setup.html"><strong aria-hidden="true">2.1.</strong> Platform-specific Setup</a></li><li class="chapter-item expanded "><a href="getting_started/installing_rust.html"><strong aria-hidden="true">2.2.</strong> Installing Rust</a></li><li class="chapter-item expanded "><a href="getting_started/editor_setup.html"><strong aria-hidden="true">2.3.</strong> Editor Setup</a></li><li class="chapter-item expanded "><a href="getting_started/running_examples.html"><strong aria-hidden="true">2.4.</strong> Running Examples</a></li><li class="chapter-item expanded "><a href="getting_started/create_a_project.html"><strong aria-hidden="true">2.5.</strong> Create A Project</a></li><li class="chapter-item expanded "><a href="getting_started/updating.html"><strong aria-hidden="true">2.6.</strong> Updating Nannou and Rust</a></li></ol></li><li class="chapter-item expanded "><a href="tutorials.html"><strong aria-hidden="true">3.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorials/basics/draw-a-sketch.html"><strong aria-hidden="true">3.1.</strong> Basics - Drawing a Sketch</a></li><li class="chapter-item expanded "><a href="tutorials/basics/anatomy-of-a-nannou-app.html"><strong aria-hidden="true">3.2.</strong> Basics - Anatomy of a Nannou App</a></li><li class="chapter-item expanded "><a href="tutorials/basics/drawing-2d-shapes.html"><strong aria-hidden="true">3.3.</strong> Basics - Drawing 2D Shapes</a></li></ol></li><li class="chapter-item expanded "><a href="developer_reference.html"><strong aria-hidden="true">4.</strong> Developer Reference</a></li><li class="chapter-item expanded "><a href="api_reference.html"><strong aria-hidden="true">5.</strong> API Reference</a></li><li class="chapter-item expanded "><a href="showcases.html"><strong aria-hidden="true">6.</strong> Showcases</a></li><li class="chapter-item expanded affix "><a href="contributors.html">Contributors</a></li><li class="chapter-item expanded affix "><a href="code_of_conduct.html">Code of Conduct</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Nannou Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#welcome" id="welcome">Welcome!</a></h1>
<p><strong>Nannou is an open-source, creative-coding toolkit for Rust.</strong></p>
<p>The aim of this guide is to help you find the information you are looking for.
Whether you are new to Nannou and are looking for a place to start, or you are
an experienced Nannou user looking for more advanced tutorials, this book should
have something for you!</p>
<p>As excited as we are about developing tools for creative coding, we are equally
excited about fostering a warm, welcoming and inclusive community. Please make
yourself familiar with our <a href="/code_of_conduct.html">Code of Conduct</a> and feel free
to join us on <a href="https://communityinviter.com/apps/nannou/nannou-slack">the Nannou
Slack</a>!</p>
<h3><a class="header" href="#a-hrefwhy_nannouhtmlwhy-nannoua" id="a-hrefwhy_nannouhtmlwhy-nannoua"><a href="/why_nannou.html">Why Nannou?</a></a></h3>
<p>Here you can read about the motivations and philosophy behind Nannou. Why start
Nannou? What drives forward progress?</p>
<h3><a class="header" href="#a-hrefgetting_startedhtmlgetting-starteda" id="a-hrefgetting_startedhtmlgetting-starteda"><a href="/getting_started.html">Getting Started</a></a></h3>
<p>Is this your first time using Nannou or Rust? This is the chapter for you.
This chapter covers everything from installing Rust right through to starting
your own Nannou project.</p>
<h3><a class="header" href="#a-hreftutorialshtmltutorialsa" id="a-hreftutorialshtmltutorialsa"><a href="/tutorials.html">Tutorials</a></a></h3>
<p>A suite of tutorials demonstrating how to do different things with Nannou. For
example, &quot;How do I output sounds?&quot;, &quot;How do I draw shapes?&quot;, &quot;How can I connect
to my laser?&quot;</p>
<h3><a class="header" href="#a-hrefdeveloper_referencehtmldeveloper-referencea" id="a-hrefdeveloper_referencehtmldeveloper-referencea"><a href="/developer_reference.html">Developer Reference</a></a></h3>
<p>Learn more about the design philosophy behind Nannou, how the project is
architected and how you can contribute.</p>
<h3><a class="header" href="#a-hrefhttpsdocsrsnannouapi-referencea" id="a-hrefhttpsdocsrsnannouapi-referencea"><a href="https://docs.rs/nannou">API Reference</a></a></h3>
<p>If you are looking for the source code reference, check out
<a href="https://docs.rs/nannou">docs.rs/nannou</a>. Here you can find documentation about
the API generated from the code itself.</p>
<h3><a class="header" href="#a-hrefshowcaseshtmlshowcasesa" id="a-hrefshowcaseshtmlshowcasesa"><a href="/showcases.html">Showcases</a></a></h3>
<p>See what's possible with Nannou! A collection of projects made with Nannou.</p>
<h1><a class="header" href="#why-nannou" id="why-nannou">Why Nannou?</a></h1>
<p><strong>nannou</strong> is a collection of code aimed at making it easy for artists to
express themselves with simple, fast, reliable, portable code.  Whether working
on a 12-month installation or a 5 minute sketch, this framework aims to give
artists easy access to the tools they need.</p>
<p>The project was started out of a desire for a creative coding framework inspired
by Processing, OpenFrameworks and Cinder, but for Rust. <sup>Named after
<a href="https://www.youtube.com/watch?v=A-Pkx37kYf4">this</a>.</sup></p>
<h2><a class="header" href="#goals" id="goals">Goals</a></h2>
<p>Nannou aims to provide easy, cross-platform access to the things that artists
need:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<strong>Windowing &amp; Events</strong> via <a href="https://crates.io/crates/winit">winit</a>.</li>
<li><input disabled="" type="checkbox" checked=""/>
<strong>Audio</strong> via <a href="https://crates.io/crates/cpal">CPAL</a>. <em>Input and
output streams. Duplex are not yet supported.</em></li>
<li><input disabled="" type="checkbox"/>
<strong>Video</strong> input, playback and processing (<em>would love suggestions and
ideas</em>).</li>
<li><input disabled="" type="checkbox" checked=""/>
<strong>GUI</strong> via <a href="https://crates.io/crates/conrod">conrod</a>. <em>May switch to a
custom nannou solution in the future</em>.</li>
<li><strong>Geometry</strong> with functions and iterators for producing vertices and indices:
<ul>
<li><input disabled="" type="checkbox" checked=""/>
1D - <code>Scalar</code>, <code>Range</code>.</li>
<li><input disabled="" type="checkbox" checked=""/>
2D - <code>Rect</code>, <code>Line</code>, <code>Ellipse</code>, <code>Polygon</code>, <code>Polyline</code>, <code>Quad</code>,
<code>Tri</code>.</li>
<li><input disabled="" type="checkbox" checked=""/>
3D - <code>Cuboid</code>.</li>
<li><input disabled="" type="checkbox"/>
3D TODO - <code>Ellipsoid</code>, <code>Cube</code>, Prisms, Pyramids, *Hedrons, etc.</li>
<li><input disabled="" type="checkbox" checked=""/>
Vertex &amp; index iterators.</li>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://docs.rs/nannou/latest/nannou/geom/graph/index.html">Graph</a> for
composing geometry.</li>
</ul>
</li>
<li><strong>Graphics</strong> via Vulkan (via <a href="https://github.com/vulkano-rs/vulkano">vulkano</a>):
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://docs.rs/nannou/latest/nannou/draw/index.html">Draw</a> API. E.g.
<code>draw.ellipse().w_h(20.0, 20.0).color(RED)</code>.</li>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://docs.rs/nannou/latest/nannou/mesh/index.html">Mesh</a> API.</li>
<li><input disabled="" type="checkbox"/>
Image API (currently only supported via GUI).</li>
<li><input disabled="" type="checkbox"/>
Framebuffer object API.</li>
</ul>
</li>
<li><strong>Protocols</strong>:
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://docs.rs/nannou/latest/nannou/osc/index.html">OSC</a> - Open Sound
Control.</li>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://github.com/nannou-org/citp">CITP</a> - Controller Interface
Transport Protocol (network implementation is in progress).</li>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://github.com/nannou-org/ether-dream">Ether-Dream</a> Laser DAC
protocol and network implementation.</li>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://github.com/lschmierer/sacn">DMX via sACN</a> - commonly used for
lighting and effects.</li>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://crates.io/crates/serial">Serial</a> - commonly used for
interfacing with LEDs and other hardware.</li>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://crates.io/crates/midir">MIDI</a> - Musical Instrument Digital
Interface.</li>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://doc.rust-lang.org/std/net/struct.UdpSocket.html">UDP</a> via
std.</li>
<li><input disabled="" type="checkbox" checked=""/>
TCP
<a href="https://doc.rust-lang.org/std/net/struct.TcpStream.html">streams</a> and
<a href="https://doc.rust-lang.org/std/net/struct.TcpListener.html">listeners</a>
via std.</li>
</ul>
</li>
<li><strong>Device &amp; I/O stream APIs</strong>:
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://docs.rs/nannou/latest/nannou/app/struct.Audio.html">Audio</a>.</li>
<li><input disabled="" type="checkbox"/>
Video.</li>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://github.com/nannou-org/lasy">Lasers</a>.</li>
<li><input disabled="" type="checkbox"/>
Lights.</li>
<li><input disabled="" type="checkbox"/>
LEDs.</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
<strong>Graphical Node Graph</strong> via <a href="https://github.com/nannou-org/gantz">gantz</a>.</li>
<li><input disabled="" type="checkbox"/>
<strong>GUI Editor</strong>.</li>
</ul>
<p>Nannou aims to <strong>use only pure-rust libraries</strong>. As a new user you should
require nothing more than <code>cargo build</code> to get going. Falling back to C-bindings
will be considered as a temporary solution in the case that there are no Rust
alternatives yet in development. We prefer to drive forward development of less
mature rust-alternatives than depend on bindings to C code. This should make it
easier for nannou <em>users</em> to become nannou <em>contributors</em> as they do not have to
learn a second language in order to contribute upstream.</p>
<p>Nannou <strong>will not contain <code>unsafe</code> code</strong> with the exception of bindings to
operating systems or hardware APIs if necessary.</p>
<p>Nannou wishes to <strong>remove the need to decide between lots of different backends
that provide access to the same hardware</strong>. Instead, we want to focus on a
specific set of backends and make sure that they work well.</p>
<h2><a class="header" href="#why-rust" id="why-rust">Why Rust?</a></h2>
<p>Rust is a language that is both highly expressive and blazingly fast. Here are
some of the reasons why we choose to use it:</p>
<ul>
<li><strong>Super fast</strong>, as in <a href="https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&amp;lang2=gpp">C and
C++ fast</a>.</li>
<li><a href="https://crates.io/"><strong>A standard package manager</strong></a> that makes it very
easy to handle dependencies and share your own projects in seconds.</li>
<li><strong>Highly portable.</strong> Easily build for MacOS, Linux, Windows, Android, iOS and
<a href="https://forge.rust-lang.org/platform-support.html">so many others</a>.</li>
<li><strong>No header files</strong> (and no weird linking errors).</li>
<li><strong>Sum Types and Pattern Matching</strong> (and no <code>NULL</code>).</li>
<li><strong>Local type inference</strong>. Only write types where it matters, no need to repeat
yourself.</li>
<li>A more modern, <strong>ƒunctional and expressive style</strong>.</li>
<li><strong>Memory safe and data-race-free!</strong> Get your ideas down without the fear of
creating pointer spaghetti or segfault time-sinks.</li>
<li><strong>Immutability by default.</strong> Easily distinguish between variables that can
change and those that can't at a glance.</li>
<li><strong>Module system</strong> resulting in very clean and concise name spaces.</li>
<li>One of the kindest internet communities we've come across (please visit
mozilla's #rust or /r/rust if you're starting out and need any pointers)</li>
</ul>
<h2><a class="header" href="#why-the-apachemit-dual-licensing" id="why-the-apachemit-dual-licensing">Why the Apache/MIT dual licensing?</a></h2>
<p>For the most part, nannou is trying to maintain as much flexibility and compatibility
with the licensing of Rust itself, which is also <a href="https://www.rust-lang.org/policies/licenses">dual licensed</a>.</p>
<p>The Apache 2.0 and MIT license are very similar, but have a few key differences.
Using the Apache 2.0 license for contributions triggers the Apache 2.0 patent grant.
This grant is designed to protect against leveraging the patent law system to bypass
(some) terms of the license. If the contribution is under the Apache 2.0 license, the
contributor assures that they will not claim a violation of (their own) patents. If
someone makes a work based on Apache 2.0 licensed code, they in turn also vow to
not sue their users (for patent infringement).
The MIT license provides compatibility with a lot of other FLOSS licenses.</p>
<p>Further reading:</p>
<ul>
<li><a href="https://opensource.org/licenses/Apache-2.0">Apache License, Version 2.0</a></li>
<li><a href="https://opensource.org/licenses/MIT">MIT License</a></li>
<li><a href="https://mail.mozilla.org/pipermail/rust-dev/2012-November/002664.html">Please read: Rust license changing (very slightly)</a></li>
<li><a href="https://internals.rust-lang.org/t/rationale-of-apache-dual-licensing/8952">Rationale of Apache dual licensing</a></li>
<li><a href="https://opensource.stackexchange.com/questions/1881/against-what-does-the-apache-2-0-patent-clause-protect">Against what does the Apache 2.0 patent clause protect?</a></li>
<li>[GPLv2 Combination Exception for the Apache 2 License]https://blog.gerv.net/2016/09/gplv2-combination-exception-for-the-apache-2-license/)</li>
</ul>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>If you are new to nannou or Rust, you are in the right place!</p>
<p>In this section, we will:</p>
<ol>
<li>Install the Rust programming language.</li>
<li>Check for platform-specific requirements.</li>
<li>Setup our code editor for working with Rust.</li>
<li>Run some nannou examples.</li>
<li>Make our own, new nannou project!</li>
</ol>
<p>Let's get started.</p>
<h1><a class="header" href="#platform-specific-setup" id="platform-specific-setup">Platform-specific Setup</a></h1>
<p>Before we get started, let's make sure we have all the necessary ingredients for
installing Rust and building nannou projects.</p>
<p>Depending on what OS you are running, you might require an extra step or two.</p>
<p>By the way, if you notice some steps are missing from this section of the guide,
feel free to open an issue or PR at <a href="https://github.com/nannou-org/guide">the nannou guide
repo</a>!</p>
<h2><a class="header" href="#macos" id="macos">macOS</a></h2>
<p>Ensure that you have xcode-tools installed:</p>
<pre><code class="language-bash">xcode-select --install
</code></pre>
<p>This should provide all the developer tools needed for building nannou.</p>
<h2><a class="header" href="#windows" id="windows">Windows</a></h2>
<p>Rust requires the C++ build tools for Visual Studio. The Rust book has this to
say:</p>
<blockquote>
<p>On Windows, go to
<a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a>
and follow the instructions for installing Rust. At some point in the
installation, you’ll receive a message explaining that you’ll also need the
C++ build tools for Visual Studio 2013 or later. The easiest way to acquire
the build tools is to install <a href="https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2019">Build Tools for Visual Studio
2019</a>.
The tools are in the Other Tools and Frameworks section.</p>
</blockquote>
<h2><a class="header" href="#linux" id="linux">Linux</a></h2>
<p>Ensure you have the following system packages installed:</p>
<ul>
<li>
<p><strong>Basic dev packages</strong></p>
<p>First make sure the basic dev packages are installed.</p>
<ul>
<li><code>curl</code> will be required by <code>rustup</code> the rust toolchain manager.</li>
<li><code>build-essential</code> will be required by <code>rustc</code> the rust compiler for linking.</li>
<li><code>pkg-config</code> is used by some build scripts to source information about
certain libraries.</li>
<li><code>alsa</code> dev packages are required for <code>nannou_audio</code>.</li>
</ul>
<p>For Debian/Ubuntu users:</p>
<pre><code class="language-bash">sudo apt-get install curl build-essential python cmake pkg-config
</code></pre>
</li>
<li>
<p><strong>alsa dev package</strong></p>
<p>For Fedora users:</p>
<pre><code class="language-bash">sudo dnf install alsa-lib-devel
</code></pre>
<p>For Debian/Ubuntu users:</p>
<pre><code class="language-bash">sudo apt-get install libasound2-dev
</code></pre>
<p>For Arch users:</p>
<pre><code class="language-bash">sudo pacman -S alsa-lib
</code></pre>
</li>
<li>
<p><strong>curl lib dev package</strong></p>
<p>Nannou depends on the <code>curl-sys</code> crate. Some Linux distributions use
LibreSSL instead of OpenSSL (such as AlpineLinux, Voidlinux, possibly
<a href="https://en.wikipedia.org/wiki/LibreSSL#Adoption">others</a> if manually
installed).</p>
</li>
<li>
<p><strong>xcb</strong></p>
<p>The XCB library provides inter-operability with Xlib.</p>
<p>For Debian/Ubuntu users:</p>
<pre><code class="language-bash">sudo apt install libxcb-shape0-dev libxcb-xfixes0-dev
</code></pre>
<p>You might also need <code>python3</code> for the <code>xcb</code> crate's build script.</p>
</li>
<li>
<p><strong>vulkan</strong></p>
<p>Installing Vulkan support on Linux is generally quite easy using your
distro's package manager. That said, there may be different driver
options to consider depending on your graphics card and tolerance for
proprietary software. The following are rough guidelines on how to get
going quickly, however if you are at all concerned with finding the
approach that suits you best we recommend searching for vulkan driver
installation for your graphics card on your distro.</p>
<p>For Fedora with AMD graphic cards:</p>
<pre><code class="language-bash">sudo dnf install vulkan vulkan-info
</code></pre>
<p>For Fedora with NVIDIA graphic cards:
Add the proprietary drivers</p>
<pre><code class="language-bash">sudo dnf install https://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://download1.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm
</code></pre>
<p>and run</p>
<pre><code class="language-bash">sudo dnf install xorg-x11-drv-nvidia akmod-nvidia vulkan-tools
</code></pre>
<p>For Debian with AMD or Intel graphic cards:</p>
<pre><code class="language-bash">sudo apt-get install libvulkan1 mesa-vulkan-drivers vulkan-utils
</code></pre>
<p>For Debian with NVIDIA graphic cards:</p>
<pre><code class="language-bash">sudo apt-get install vulkan-utils
</code></pre>
<p>For Ubuntu users with AMD or Intel graphic cards:
Add a PPA for the latest drivers</p>
<pre><code class="language-bash">sudo add-apt-repository ppa:oibaf/graphics-drivers
sudo apt-get update
sudo apt-get upgrade
</code></pre>
<p>and run</p>
<pre><code class="language-bash">sudo apt-get install libvulkan1 mesa-vulkan-drivers vulkan-utils
</code></pre>
<p>For Ubuntu users with NVIDIA graphic cards:
Add a PPA for the latest drivers</p>
<pre><code class="language-bash">sudo add-apt-repository ppa:graphics-drivers/ppa
sudo apt-get update
sudo apt-get upgrade
</code></pre>
<p>and run</p>
<pre><code class="language-bash">sudo apt-get install nvidia-graphics-drivers-396 nvidia-settings vulkan vulkan-utils
</code></pre>
<p>For Arch with AMD graphic cards:</p>
<pre><code class="language-bash">sudo pacman -S vulkan-radeon lib32-vulkan-radeon
</code></pre>
<p>For Arch with Intel graphics card:</p>
<pre><code class="language-bash">sudo pacman -S vulkan-intel
</code></pre>
<p>For Arch with NVIDIA graphic cards:</p>
<pre><code class="language-bash">sudo pacman -S nvidia lib32-nvidia-utils
</code></pre>
<p>For Gentoo run:</p>
<pre><code class="language-bash">sudo emerge --ask --verbose dev-util/vulkan-tools dev-util/vulkan-headers
</code></pre>
</li>
</ul>
<p>OK, we should now be ready to install Rust!</p>
<h1><a class="header" href="#installing-rust" id="installing-rust">Installing Rust</a></h1>
<p>Nannou is a library written for the <a href="https://www.rust-lang.org/">Rust programming
language</a>. Thus, the first step is to install Rust!</p>
<p>To install Rust on <strong>Windows</strong>, download and run the installer from
<a href="https://www.rust-lang.org/tools/install">here</a>. If you're on <strong>macOS</strong> or
<strong>Linux</strong>, open up your terminal, copy the text below, paste it into your
terminal and hit enter.</p>
<pre><code class="language-bash">curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>Now Rust is installed!</p>
<p>Next we will install some tools that help IDEs do fancy things like
auto-completion and go-to-definition.</p>
<pre><code class="language-bash">rustup component add rust-src rustfmt-preview rust-analysis
</code></pre>
<p>Please see <a href="https://www.rust-lang.org/tools/install">this link</a> if you would
like more information on the Rust installation process.</p>
<h1><a class="header" href="#editor-setup" id="editor-setup">Editor Setup</a></h1>
<p>While most popular development environments support Rust, support for certain
features like auto-completion and go-to-definition is better in some than
others.</p>
<h3><a class="header" href="#vs-code" id="vs-code">VS Code</a></h3>
<p>For new Rust users we recommend using VS-Code as your editor and IDE for Nannou
development. Currently it seems to have the best support for the Rust language
including syntax highlighting, auto-complete, code formatting and more. It also
comes with an integrated unix terminal and file navigation system. Below are the
steps we recommend for getting started with Nannou development using VS-Code.</p>
<ol>
<li><a href="https://code.visualstudio.com/download">Download VS-Code</a> for your OS.</li>
<li>In VS code user settings, set <code>&quot;rust-client.channel&quot;: &quot;stable&quot;</code>.</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust">Install
RLS</a> (the
Rust Language Server) plugin for VS-Code.</li>
<li>Click on the 'view' menu and select 'integrated terminal'.</li>
</ol>
<h3><a class="header" href="#other-environments" id="other-environments">Other Environments</a></h3>
<p>Here are links to assist with setting up other popular development environments
for supporting Rust.</p>
<ol>
<li><a href="https://packagecontrol.io/packages/Rust%20Enhanced">Sublime Text</a></li>
<li><a href="https://atom.io/packages/language-rust">Atom</a></li>
<li><a href="https://intellij-rust.github.io">Intellij IDEA</a></li>
<li><a href="https://github.com/rust-lang/rust.vim">Vim</a></li>
<li><a href="https://github.com/rust-lang/rust-mode">Emacs</a></li>
<li><a href="https://github.com/PistonDevelopers/VisualRust">Visual Studio</a></li>
<li><a href="https://github.com/eclipse/corrosion">Eclipse</a></li>
</ol>
<h1><a class="header" href="#running-examples" id="running-examples">Running Examples</a></h1>
<p>The easiest way to get familiar with nannou is to explore the examples.</p>
<p>Nannou provides three collections of examples:</p>
<table><thead><tr><th><strong>Path</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td><a href="https://github.com/nannou-org/nannou/tree/master/examples"><strong><code>examples/</code></strong></a></td><td>A collection of examples with categorised demonstrations of nannou.</td></tr>
<tr><td><a href="https://github.com/nannou-org/nannou/tree/master/generative_design"><strong><code>generative_design/</code></strong></a></td><td>Examples from <a href="http://www.generative-gestaltung.de/">Generative Gestaltung</a>, ported from p5.js to nannou.</td></tr>
<tr><td><a href="https://github.com/nannou-org/nannou/tree/master/nature_of_code"><strong><code>nature_of_code/</code></strong></a></td><td>Examples from <a href="https://natureofcode.com/">Nature of Code</a>, ported from Processing to nannou.</td></tr>
</tbody></table>
<p>To get the examples we can clone the nannou repository.</p>
<pre><code class="language-bash">git clone https://github.com/nannou-org/nannou
</code></pre>
<p>If you do not have <code>git</code> installed you can press the &quot;Clone or download&quot; button
at the top of this page and then press &quot;Download .zip&quot;.</p>
<p>Now, change the current directory to <code>nannou</code>.</p>
<pre><code class="language-bash">cd nannou
</code></pre>
<p>Run the example using cargo!</p>
<pre><code class="language-bash">cargo run --release --example draw
</code></pre>
<p>The <code>--release</code> flag means we want to build with optimisations enabled.</p>
<p>The value passed via the <code>--example</code> flag matches the <code>name</code> property of an
entry within the <code>[[examples]]</code> table of the package's <code>Cargo.toml</code> file. The
matched entry's <code>path</code> property points to the source file to build:</p>
<pre><code class="language-toml"># Draw
[[example]]
name = &quot;draw&quot;
path = &quot;draw/draw.rs&quot;
</code></pre>
<p>If we were to look through the nature of code directory and decide we want to
run the following example:</p>
<pre><code class="language-toml"># Chapter 1 Vectors
[[example]]
name = &quot;1_1_bouncingball_novectors&quot;
path = &quot;chp_01_vectors/1_1_bouncingball_novectors.rs&quot;
</code></pre>
<p>We could do so with the following:</p>
<pre><code class="language-bash">cargo run --release --example 1_1_bouncingball_novectors
</code></pre>
<p>In general, the name of the example will almost always be the file name without
the <code>.rs</code> extension.</p>
<p>If you are compiling nannou for the first time you will see cargo download and
build all the necessary dependencies. This might take a while! Luckily, we only
have to wait for this the first time.</p>
<p><img src="https://i.imgur.com/5OBNqMB.gif" alt="cargo" /></p>
<p>Once the example compiles you should see the following window appear.</p>
<p><img src="https://i.imgur.com/HVVamUI.gif" alt="draw_HD" /></p>
<p>To run any of the other examples, replace <code>draw</code> with the name of the
desired example.</p>
<h1><a class="header" href="#create-a-project" id="create-a-project">Create A Project</a></h1>
<p>Whether we are creating an artwork, an app, a quick sketch or an installation,
we want to begin by creating a new project. A new nannou project lets us build a
nannou application the way that <em>we</em> want to use it.</p>
<p>Eventually, the aim for Nannou is to provide a project generator tool which will
allow us to do the following and much more in just a few clicks. For now, we can
create a new project with just a few small steps:</p>
<ol>
<li>
<p>Create the Rust project with the name of our project:</p>
<pre><code class="language-bash">cargo new my-project
</code></pre>
</li>
<li>
<p>Change directory to the generated project.</p>
<pre><code class="language-bash">cd my-project
</code></pre>
</li>
<li>
<p>Edit the <code>Cargo.toml</code> file and add the latest version of nannou to the bottom
like so:</p>
<pre><code class="language-toml">[package]
name = &quot;my_project&quot;
version = &quot;0.1.0&quot;
authors = [&quot;mitchmindtree &lt;mitchell.nordine@gmail.com&gt;&quot;]
edition = &quot;2018&quot;

[dependencies]
nannou = &quot;0.12&quot;
</code></pre>
<p>Note that there is a chance the nannou version above might be out of date.
You can check the latest version by typing <code>cargo search nannou</code> in your
terminal.</p>
</li>
<li>
<p>Replace the code in <code>src/main.rs</code> with the following to setup our nannou
application.</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">extern crate nannou;
</span>use nannou::prelude::*;

fn main() {
    nannou::app(model)
        .update(update)
        .simple_window(view)
        .run();
}

struct Model {}

fn model(_app: &amp;App) -&gt; Model {
    Model {}
}

fn update(_app: &amp;App, _model: &amp;mut Model, _update: Update) {
}

fn view(_app: &amp;App, _model: &amp;Model, frame: Frame){
    frame.clear(PURPLE);
}
</code></pre></pre>
<p>If you are new to Rust or simply do not understand the code above just yet,
do not fear! In the first tutorial of the next chapter we will break down
this code step-by-step.</p>
</li>
<li>
<p>Trigger the initial build and check that everything is working nicely by
running our app!</p>
<pre><code class="language-bash">cargo run --release
</code></pre>
<p>The first build might take a while, as we must build nannou and all of its
dependencies from scratch. The following times that we run our app should be
much faster!</p>
<p>Once the project has finished building, it will begin running and we should
be able to see a purple window.</p>
</li>
</ol>
<p><strong>That's it!</strong> If everything went as planned, you are now ready to start
building your own nannou project. Of course, we probably want our application to
be more than just a purple window.</p>
<p>To find out how to add more features to our project like graphics, audio,
multiple windows, laser output, projection mapping and much more, let's take a
look at the next chapter.</p>
<h1><a class="header" href="#updating-nannou" id="updating-nannou">Updating nannou</a></h1>
<p>You can update to a new version of nannou by editing your <code>Cargo.toml</code> file to
use the new crate. For version 0.12 add the line</p>
<pre><code class="language-toml">nannou = &quot;0.12&quot;
</code></pre>
<p>Then within the nannou directory run the following to update all dependencies:</p>
<pre><code class="language-bash">cargo update
</code></pre>
<h2><a class="header" href="#updating-rust" id="updating-rust">Updating Rust.</a></h2>
<p>From time to time, a nannou update might require features from a newer version
of rustc. For example, nannou 0.12 is known to require at least rustc 1.35.0. In
these cases, you can update your rust toolchain to the latest version by running
the following:</p>
<pre><code class="language-bash">rustup update
</code></pre>
<h1><a class="header" href="#tutorials" id="tutorials">Tutorials</a></h1>
<p>In the previous chapter we prepared everything needed to start our own Nannou
project! In this chapter, we will take a more focused look at all of the
different features we can add to our Nannou project.</p>
<p>If you are new to Nannou or Rust we recommend starting with the first tutorial
before going on. If you are feeling more confident, feel free to choose your own
adventure through the following tutorials depending on what you want to add to
your project!</p>
<h2><a class="header" href="#basics" id="basics">Basics</a></h2>
<p>A suite of tutorials for getting familiar with Rust and the Nannou environment.</p>
<ul>
<li><a href="/tutorials/basics/draw-a-sketch.html">Drawing a sketch</a></li>
<li><a href="/tutorials/basics/anatomy-of-a-nannou-app.html">Anatomy of a nannou app</a></li>
<li>Nannou events</li>
<li>Rust variables</li>
<li>Rust conditions</li>
<li>Rust loops</li>
<li>Rust functions</li>
</ul>
<h2><a class="header" href="#drawing" id="drawing">Drawing</a></h2>
<p>Working with Nannou's <code>Draw</code> API - a simple approach of coding graphics.</p>
<ul>
<li><a href="/tutorials/basics/drawing-2d-shapes.html">Drawing 2D shapes</a></li>
<li>Drawing 3D shapes</li>
<li>Drawing images</li>
<li>Drawing meshes</li>
</ul>
<h2><a class="header" href="#windowing" id="windowing">Windowing</a></h2>
<p>Walk-throughs for creating and working with one or more windows.</p>
<ul>
<li>Building a custom window</li>
<li>Creating multiple windows</li>
<li>Drawing to different windows</li>
<li>Fullscreen on startup</li>
<li>Automatically positioning windows</li>
</ul>
<h2><a class="header" href="#gui" id="gui">GUI</a></h2>
<p>How to create a GUI (Graphical User Interface) for you Nannou project.</p>
<ul>
<li>Creating a UI</li>
<li>Exploring available UI widgets</li>
<li>Multi-window UI</li>
</ul>
<h2><a class="header" href="#audio" id="audio">Audio</a></h2>
<p>A suite of guides for working with audio in Nannou.</p>
<ul>
<li>Setting up audio output</li>
<li>Setting up audio input</li>
<li>Selecting specific audio devices</li>
<li>Playing an audio file</li>
<li>Basic audio synthesis</li>
<li>Many channel audio streams</li>
<li>Feeding audio input to output</li>
<li>Visualising audio</li>
</ul>
<h2><a class="header" href="#video" id="video">Video</a></h2>
<p>Loading, playing and recording video in Nannou.</p>
<ul>
<li>Drawing video</li>
<li>Recording a window to video</li>
<li>Manipulating video playback</li>
</ul>
<h2><a class="header" href="#vulkan" id="vulkan">Vulkan</a></h2>
<p>Understanding the lower level that underlies all graphics in Nannou.</p>
<ul>
<li>What is Vulkan?</li>
<li>The graphics pipeline</li>
<li>Compute shaders</li>
<li>Fragment shaders</li>
<li>Vertex shaders</li>
</ul>
<h2><a class="header" href="#projection-mapping" id="projection-mapping">Projection Mapping</a></h2>
<p>Getting started with using Nannou for projection mapping.</p>
<ul>
<li>Basic quad-warping.</li>
</ul>
<h2><a class="header" href="#lasers" id="lasers">LASERs</a></h2>
<p>Detecting and outputting to LASER DACs on a network.</p>
<ul>
<li>Connecting to a LASER.</li>
<li>Detecting LASER DACs.</li>
<li>Tweaking LASER interpolation and optimisations.</li>
</ul>
<h2><a class="header" href="#osc" id="osc">OSC</a></h2>
<ul>
<li>Setting up an OSC sender.</li>
<li>Setting up an OSC receiver.</li>
</ul>
<h2><a class="header" href="#dmx" id="dmx">DMX</a></h2>
<p>Working with DMX over the network via sACN.</p>
<ul>
<li>Working with the sacn crate.</li>
</ul>
<h2><a class="header" href="#serial-over-usb" id="serial-over-usb">Serial over USB</a></h2>
<p>Working with Serial data in a cross-platform manner.</p>
<ul>
<li>Reading USB serial data.</li>
<li>Writing USB serial data.</li>
</ul>
<p>If you were unable to find what you were looking for above, or if you have an
idea for a tutorial not yet present, please feel free to create an issue or a
pull request!</p>
<h1><a class="header" href="#draw-a-nannou-sketch" id="draw-a-nannou-sketch">Draw a Nannou Sketch</a></h1>
<p><strong>Tutorial Info</strong></p>
<ul>
<li>Author: tpltnt</li>
<li>Required Knowledge: <a href="tutorials/basics//getting_started.html">Getting Started</a></li>
<li>Reading Time: 5 minutes</li>
</ul>
<hr />
<p><strong>Nannou is a framework for creative coding in Rust.</strong> A framework can be
thought of as a collection of building blocks to help accomplish a goal.
If you are not familiar with the programming language Rust, please work
through some of <a href="https://www.rust-lang.org/learn">this material first</a>.</p>
<p>A sketch is the smallest/fastest way to get results with nannou.
Here is one example which just yields a blue window:</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">extern crate nannou;
</span><span class="boring">
</span>// minimal example of a nannou sketch
use nannou::prelude::*;

fn main() {
    nannou::sketch(view).run();
}

fn view(app: &amp;App, frame: Frame) {
    // get canvas to draw on
    let draw = app.draw();

    // set background to blue
    draw.background().color(BLUE);

    // put everything on the frame
    draw.to_frame(app, &amp;frame).unwrap();
}
</code></pre></pre>
<p>You can exit the sketch by pressing <code>ESC</code>.</p>
<h2><a class="header" href="#sidenote-sketches-vs-apps" id="sidenote-sketches-vs-apps">Sidenote: Sketches vs. Apps</a></h2>
<p>Nannou can be used to create many things with very different levels
of complexity, similar to pen and paper. Sketches are more like
squiggles on napkins while apps can be really elaborate drawings.
Sketches offer a constrained space to work with, but a lot is taken
care of behind the scenes. Apps allow for more fine grained control,
but also require more (explicit) work on your part. The main difference
is that an app provides a model for working with state, while a
sketch provides a simpler API to get drawing quickly. A good
overview of how apps work can be found in the chapter
<a href="tutorials/basics//tutorials/basics/anatomy-of-a-nannou-app.html">Anatomy of a nannou app</a>.</p>
<h2><a class="header" href="#explaining-the-code" id="explaining-the-code">Explaining the Code</a></h2>
<p>A sketch consists of at least two functions: <code>main()</code> and <code>view()</code>.
First we import some building blocks:</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#![allow(unused_imports)]
</span>use nannou::prelude::*;
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>After this import the actual sketching code starts. The <code>main()</code> functions is where all your logic starts. The code</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">extern crate nannou;
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    nannou::sketch(view).run();
<span class="boring">}
</span><span class="boring">fn view(_app: &amp;App, _frame: Frame) {}
</span></code></pre></pre>
<p>call a function to draw on the single window (<code>view()</code> in this case). This
function has the signature <code>fn(_: &amp;App, _: Frame);</code>. Don't worry if you
don't know what a function signature is. Just copy the <code>main()</code> function
and you will be fine.</p>
<p>Within the view() function, what we draw to the Frame will be presented in our window.</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#![allow(unused_imports)]
</span><span class="boring">extern crate nannou;
</span><span class="boring">
</span><span class="boring">// minimal example of a nannou sketch
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">   nannou::sketch(view).run();
</span><span class="boring">}
</span><span class="boring">
</span>fn view(app: &amp;App, frame: Frame) {
    let draw = app.draw();

    draw.background().color(BLUE);

    draw.to_frame(app, &amp;frame).unwrap();
}
</code></pre></pre>
<p>This function follows the same scheme. First some setup is done. The line</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#![allow(unused_imports)]
</span><span class="boring">#![allow(unused_variables)]
</span><span class="boring">extern crate nannou;
</span><span class="boring">
</span><span class="boring">// minimal example of a nannou sketch
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">   nannou::sketch(view).run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn view(app: &amp;App, _frame: Frame) {
</span>let draw = app.draw();
<span class="boring">}
</span></code></pre></pre>
<p>lets us assign a canvas-like datatype to the variable <code>draw</code>.
We can now paint on the this canvas by setting the background to blue.</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#![allow(unused_imports)]
</span><span class="boring">extern crate nannou;
</span><span class="boring">
</span><span class="boring">// minimal example of a nannou sketch
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">   nannou::sketch(view).run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn view(app: &amp;App, _frame: Frame) {
</span><span class="boring">let draw = app.draw();
</span>draw.background().color(BLUE);
<span class="boring">}
</span></code></pre></pre>
<p>Now we have a canvas with only a blue background. We take this canvas and
create a computer graphics frame from it to display in the main window.</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#![allow(unused_imports)]
</span><span class="boring">extern crate nannou;
</span><span class="boring">
</span><span class="boring">// minimal example of a nannou sketch
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">   nannou::sketch(view).run();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn view(app: &amp;App, frame: Frame) {
</span><span class="boring">let draw = app.draw();
</span>draw.to_frame(app, &amp;frame).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>Note that the <code>view()</code> function is called repeatedly, but not at a constant
rate. This might be problematic if you use randomness to draw things.</p>
<h1><a class="header" href="#anatomy-of-a-nannou-app" id="anatomy-of-a-nannou-app">Anatomy of a Nannou App</a></h1>
<p><strong>Tutorial Info</strong></p>
<ul>
<li>Author: tpltnt, mitchmindtree</li>
<li>Required Knowledge: <a href="tutorials/basics//getting_started.html">Getting Started</a></li>
<li>Reading Time: 10 minutes</li>
</ul>
<hr />
<p><strong>Nannou is a framework for creative coding in Rust.</strong> A framework can be
thought of as a collection of building blocks to help accomplish a goal.</p>
<p>If romance stories were frameworks, then you might have the protagonist, their
love interest, some struggles, and a happy ending as the building blocks. All of
these need to be fleshed out by the author, but using clichés help to tell a
story without having to introduce everyone and everything in excruciating
detail. If the author wants to tell a horror story, then the clichés of a
romance story aren't very helpful.</p>
<p>In the same way you can use nannou to create programs for artistic expression,
but you might find it hard to build an office suite. So let's take a look at the
building blocks for creative coding together.</p>
<p>Here's an example of a bare-bones nannou app that opens an empty window:</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">extern crate nannou;
</span><span class="boring">
</span>use nannou::prelude::*;

struct Model {}

fn main() {
    nannou::app(model)
        .event(event)
        .simple_window(view)
        .run();
}

fn model(_app: &amp;App) -&gt; Model {
    Model {}
}

fn event(_app: &amp;App, _model: &amp;mut Model, _event: Event) {
}

fn view(_app: &amp;App, _model: &amp;Model, _frame: Frame) {
}
</code></pre></pre>
<p>We will start from the top!</p>
<h2><a class="header" href="#import-common-items" id="import-common-items">Import Common Items</a></h2>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#![allow(unused_imports)]
</span><span class="boring">extern crate nannou;
</span>use nannou::prelude::*;
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>This line imports all of the commonly used items from nannou into scope. These
include items such as <code>App</code>, <code>Frame</code>, and many more that we will learn about
over time. To see the full list of items re-exported by the prelude, see
<a href="https://docs.rs/nannou/latest/nannou/prelude/index.html">here</a>.</p>
<blockquote>
<p>Note: Unlike some other languages, Rust does not automatically include
everything from the libraries added to the project. This approach results in
very clean namespaces and avoids conflicts between different items from
different crates. That said, it also means we need to manually import every
item we <em>do</em> want to use into scope. By providing a prelude nannou makes it a
little easier to access all of the commonly used items.</p>
</blockquote>
<h2><a class="header" href="#model---our-app-state" id="model---our-app-state"><strong>Model</strong> - Our app state</a></h2>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span>struct Model {}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>The <strong>Model</strong> is where we define the state of our application. We can think of
the model as the representation of our program at any point in time. Throughout
the life of our program, we can update the model as certain events occur such as
mouse presses, key presses or timed updates. We can then present the model using
some kind of output, e.g. by drawing to the screen or outputting to a laser. We
will look at these input and output events in more detail in another tutorial!
Our example is as simple as possible, and we have no state to track. Thus our
model can stay empty.</p>
<blockquote>
<p>Note: A <code>struct</code> describes a set of data. Our struct has no fields and thus is
empty. There is no state information to be tracked in this example.</p>
</blockquote>
<h2><a class="header" href="#main---where-rust-programs-begin-and-end" id="main---where-rust-programs-begin-and-end"><strong>main</strong> - Where Rust programs begin and end</a></h2>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">extern crate nannou;
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model {}
</span>fn main() {
    nannou::app(model)
        .event(event)
        .simple_window(view)
        .run();
}
<span class="boring">fn model(_app: &amp;App) -&gt; Model {
</span><span class="boring">    Model {}
</span><span class="boring">}
</span><span class="boring">fn event(_app: &amp;App, _model: &amp;mut Model, _event: Event) {
</span><span class="boring">}
</span><span class="boring">fn view(_app: &amp;App, _model: &amp;Model, _frame: Frame) {
</span><span class="boring">}
</span></code></pre></pre>
<p>All Rust programs begin executing at the start of the <code>main</code> function and end
when the <code>main</code> function ends. In most nannou programs, the main function is
quite small. In short, we build a description of our app and then run it!</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">extern crate nannou;
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model {}
</span><span class="boring">fn main() {
</span>    nannou::app(model)       // Start building the app and specify our `model`
        .event(event)        // Specify that we want to handle app events with `event`
        .simple_window(view) // Request a simple window to which we'll draw with `view`
        .run();              // Run it!
<span class="boring">}
</span><span class="boring">fn model(_app: &amp;App) -&gt; Model {
</span><span class="boring">    Model {}
</span><span class="boring">}
</span><span class="boring">fn event(_app: &amp;App, _model: &amp;mut Model, _event: Event) {
</span><span class="boring">}
</span><span class="boring">fn view(_app: &amp;App, _model: &amp;Model, _frame: Frame) {
</span><span class="boring">}
</span></code></pre></pre>
<p>We will describe what these <strong>model</strong>, <strong>event</strong> and <strong>view</strong> functions do
below!</p>
<blockquote>
<p>Note: In this app building process we get a hint at the fundamental design
archetype of nannou apps. The approach is roughly based on the
<a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">Model-View-Controller (MVC)
pattern</a>,
though equally inspired by <a href="https://en.wikipedia.org/wiki/Functional_reactive_programming">Functional Reactive Programming
(FRP)</a>.</p>
<p>In general, these paradigms split a program into:</p>
<ul>
<li>a <strong>model</strong> describing the internal state</li>
<li>a <strong>view</strong> describing how to present the model and</li>
<li>a <strong>controller</strong> describing how to update the model on certain events.</li>
</ul>
<p>If you zoom out a bit you can think of the computer as a model, the screen as
a view (the audio output could also be thought of as a view), and the keyboard
(or mouse) as the controller. A user looks at the view and can change the
state of the model using the controller. If a program does not require user
input, the controller might use an algorithm based on time or some other
application event to modify the model.</p>
</blockquote>
<h2><a class="header" href="#model---initialise-our-model" id="model---initialise-our-model"><strong>model</strong> - initialise our Model</a></h2>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">extern crate nannou;
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model {}
</span>fn model(_app: &amp;App) -&gt; Model {
    Model {}
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>The <code>model</code> function is run once at the beginning of the nannou app and produces
a fresh, new instance of the <strong>Model</strong> that we declared previously, AKA the app
state. This can be thought of as the &quot;setup&quot; stage of our application. Here, we
might do things like create some windows, create a GUI, load some images or
anything else that we want to happen once at the beginning of our program. We
will learn how to do all of these things in future tutorials, but for now we
will just return an instance of our empty <strong>Model</strong>.</p>
<blockquote>
<p>Note: To assist with the creation of windows, GUIs, audio streams and other
kinds of I/O, access to the <strong>App</strong> is provided as an <em>input</em> to the function.
The <strong>App</strong> type can be thought of as a helper type that wraps up the finicky
details of the application (such as establishing event loops, spawning I/O
streams, etc) and provides an easy to use, high-level API on top. Providing
access to the <strong>App</strong> via a function's first argument is a common practice
throughout nannou's API.</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">extern crate nannou;
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model {}
</span>//                ----- Access to the `App` passed as an input to the function.
//               /
//              v
fn model(_app: &amp;App) -&gt; Model {
    Model {}
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>You can learn more about what the <strong>App</strong> is responsible for and capable of
<a href="https://docs.rs/nannou/latest/nannou/app/struct.App.html">here</a>.</p>
</blockquote>
<h2><a class="header" href="#event---updating-the-model-on-app-events" id="event---updating-the-model-on-app-events"><strong>event</strong> - updating the Model on app events</a></h2>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">extern crate nannou;
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model {}
</span>fn event(_app: &amp;App, _model: &amp;mut Model, _event: Event) {
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>The <strong>event</strong> function is some code that will run every time some kind of app
event occurs. There are many different kinds of app events including mouse and
keyboard presses, window resizes, timed updates and many more. Each of these are
events during which we may wish to update our <strong>Model</strong> in some way. For
example, we may wish to turn a camera when a mouse is moved, begin drawing a
shape when a button is pressed, or step forward an animation on timed updates.</p>
<p>All of these events are described within the <strong>Event</strong> type. One way to
distinguish between which event is currently occurring is to <a href="https://doc.rust-lang.org/book/ch06-02-match.html">&quot;pattern
match&quot;</a> on the event and
handle only those events that we care about, ignoring all the others. A simpler
approach is to not register an <strong>event</strong> function while building the app at all,
and instead only register more specific functions for those events that we care
about.</p>
<p>For example, if instead of handling <em>all</em> events we only want to handle timed
updates (an event that by default occurs 60 times per second) we could change
our app building code to this:</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">extern crate nannou;
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model {}
</span>fn main() {
    nannou::app(model)
        .update(update) // rather than `.event(event)`, now we only subscribe to updates
        .simple_window(view)
        .run();
}
<span class="boring">fn model(_app: &amp;App) -&gt; Model {
</span><span class="boring">    Model {}
</span><span class="boring">}
</span><span class="boring">fn update(_app: &amp;App, _model: &amp;mut Model, _update: Update) {
</span><span class="boring">}
</span><span class="boring">fn view(_app: &amp;App, _model: &amp;Model, _frame: Frame) {
</span><span class="boring">}
</span></code></pre></pre>
<p>And remove our <code>event</code> function in favour of an <code>update</code> function:</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">extern crate nannou;
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model {}
</span>fn update(_app: &amp;App, _model: &amp;mut Model, _update: Update) {
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>Now, our new <strong>update</strong> function will only run each time a timed update
occurs.</p>
<blockquote>
<p>Note: Nannou provides a whole suite of different events that may be registered
while building an app or window in this way. See the <a href="https://github.com/nannou-org/nannou/blob/master/examples/nannou_basics/all_functions.rs">all_functions.rs
example</a>
for a demonstration of most of the different kinds of events that are
available.</p>
</blockquote>
<h2><a class="header" href="#view---presenting-the-model-to-a-window" id="view---presenting-the-model-to-a-window"><strong>view</strong> - presenting the Model to a window</a></h2>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">extern crate nannou;
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model {}
</span>fn view(_app: &amp;App, _model: &amp;Model, _frame: Frame) {
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>Finally, the <strong>view</strong> allows us to present the state of the model to a window by
drawing to its <strong>Frame</strong> and returning the frame at the end. Here we can change
the background colour, use the <strong>Draw</strong> API to draw a scene, draw a GUI to the
window or even use the wgpu API to draw to the frame using our own textures and
render passes. All of this will be covered by future tutorials.</p>
<h2><a class="header" href="#concluding-remarks" id="concluding-remarks">Concluding Remarks</a></h2>
<p>Hopefully this has given you a rough idea of how nannou apps work! Do not stress
if some of the syntax looks confusing or some of the specifics still seem
unclear - we will aim to cover these and more in future tutorials :)</p>
<h1><a class="header" href="#drawing-2d-shapes" id="drawing-2d-shapes">Drawing 2D Shapes</a></h1>
<p>In this tutorial we explore drawing 2D shapes with nannou.  We will cover drawing basic lines, simple polygons (e.g. ellipses, rectangles, etc.), and more complex polygons (where you can create whatever shape you'd like)!</p>
<p>To begin with, we will need a nannou project file to work with.  Copy the following into new file:</p>
<pre><pre class="playpen"><code class="language-rust no_run">use nannou::prelude::*;

fn main() {
    nannou::sketch(view).run();
}

fn view(app: &amp;App, frame: Frame) {
    // Prepare to draw.
    let draw = app.draw();

    // Clear the background to purple.
    draw.background().color(PLUM);

    // Draw a blue ellipse with default size and position.
    draw.ellipse().color(STEELBLUE);

    // Write to the window frame.
    draw.to_frame(app, &amp;frame).unwrap();
}
</code></pre></pre>
<p>You can also find this file, and other useful examples, in the <a href="https://github.com/nannou-org/nannou/tree/master/examples">examples</a> directory of the nannou source repository.</p>
<h2><a class="header" href="#drawing-simple-shapes" id="drawing-simple-shapes">Drawing Simple Shapes</a></h2>
<p>Let's try running the file!  (if you haven't already, you will need to add this file to your Cargo.toml file)</p>
<p>You should a new window with something that looks like this:</p>
<p><img src="tutorials/basics/./images/2d-shape-circle.png" alt="A simple circle" /></p>
<p>Already we are rendering a circle to our canvas.  As you may have guessed, the line of code responsible for creating a circle is the call to the <code>ellipse</code> function:</p>
<pre><code>draw.ellipse()
    .color(STEELBLUE);
</code></pre>
<p>There are many ways we can alter our circle here.  Let's start with changing the size:</p>
<pre><code>draw.ellipse()
    .color(STEELBLUE)
    .w(300.0)
    .h(200.0);
</code></pre>
<p>The <code>w</code> function here changes the width of the ellipse to 300 pixels, and the <code>h</code> function changes the height to 200.0 pixels. You should see what we would more colloquially refer to as an ellipse.</p>
<p>We can also change the position of our ellipse with the <code>x_y</code> method:</p>
<pre><code>draw.ellipse()
    .color(STEELBLUE)
    .w(300.0)
    .h(200.0)
    .x_y(200.0, -100.0);
</code></pre>
<p><img src="tutorials/basics/./images/2d-shape-ellipse.png" alt="An ellipse" /></p>
<p>As you can see, we edit our ellipse by chaining together different methods which will change one or more properties of our shape.  This is called the <strong>Builder</strong> pattern.  The call to <code>draw.ellipse()</code> returns an object of type <code>Drawing&lt;Ellipse&gt;</code>.  In turn, each call to a builder method, such as <code>w(300.0)</code> or <code>x_y(200.0, -100.0)</code>, returns the same instance of our shape. By chaining these function calls, we are able to build an ellipse with the attributes we want.</p>
<p>There are several more methods we can use to build our ellipse. You can view the documentation for many of these methods <a href="https://docs.rs/nannou/latest/nannou/draw/struct.Drawing.html">here</a>.</p>
<h3><a class="header" href="#drawing-rectangles-and-quadrilaterals" id="drawing-rectangles-and-quadrilaterals">Drawing Rectangles and Quadrilaterals</a></h3>
<p>Drawing a square or rectangle uses the same builder pattern that drawing an ellipse does.  In fact, it's similar enough that you can swap out <code>ellipse</code> with <code>rect</code> in the example above to get a working example:</p>
<pre><code>draw.rect()
    .color(STEELBLUE)
    .w(300.0)
    .h(200.0);
</code></pre>
<p>You will see an image like this:</p>
<p><img src="tutorials/basics/./images/2d-shape-rect.png" alt="A rectangle" /></p>
<p>In addition to <code>rect</code>, you can also use the <code>quad</code> method, which is for drawing quadrilaterals. This function is similar to <code>rect</code>, but you can also choose to supply your own coordinates for your shape.  Try the following:</p>
<pre><code>let point1 = pt2(-10.0, -20.0);
let point2 = pt2(10.0, -30.0);
let point3 = pt2(15.0, 40.0);
let point4 = pt2(-20.0, 35.0);

draw.quad()
    .color(STEELBLUE)
    .w(300.0)
    .h(200.0)
    .points(point1, point2, point3, point4);
</code></pre>
<p>You should see the following:</p>
<p><img src="tutorials/basics/./images/2d-shape-quad.png" alt="A quadrilateral with custom defined points" /></p>
<p>The <code>pt2</code> method above will create a point object that represents a point in XY coordinate space, like a graph or a Cartesian plane. nannou's coordinate system places (0,0) at the center of the window. This is <strong>not</strong> like many other graphical creative coding frameworks, which place (0,0) at the upper-leftmost position of the window.</p>
<p>Note that while the <code>Drawing</code> builder objects for different shapes share many of the same builder methods, they do not share all of them.  Trying to use the method <code>points</code> on an instance of an <code>Drawing&lt;Ellipse&gt;</code>, for example, will raise an error.</p>
<h3><a class="header" href="#drawing-a-triangle" id="drawing-a-triangle">Drawing a Triangle</a></h3>
<p>Additionally, there is one more simple shape method: <code>tri</code>, for drawing triangles.  It behaves similarly to <code>quad</code>, where you can supply your own coordinates to decide how the shape looks.  Try it out!</p>
<p><img src="tutorials/basics/./images/2d-shape-tri.png" alt="A triangle" /></p>
<h2><a class="header" href="#drawing-lines" id="drawing-lines">Drawing Lines</a></h2>
<p>The <code>line</code> function provides a simple way to draw a line:</p>
<pre><code>let start_point = pt2(-30.0, -20.0);
let end_point   = pt2(40.0, 40.0);

draw.line()
    .start(start_point)
    .end(end_point)
    .weight(4.0)
    .color(STEELBLUE);
</code></pre>
<p><img src="tutorials/basics/./images/2d-simple-line.png" alt="A simple line" /></p>
<p>Simply provide a starting point and an ending point, and you have your line.</p>
<p>This is great for simpler drawings, but what if you want to draw something more complicated? A sine wave, for instance.</p>
<p>To draw our sine wave, we will use the <code>polyline</code> function.  To use this function, we will supply a collection (or array) of points that represent points on a sine wave.  We can generate this array of points using—what else—the <code>sin</code> function!</p>
<pre><code>let points = (0..50).map(|i| {
  let x = (i as f32 - 25.0);          //subtract 25 to center the sine wave
  let point = pt2(x, x.sin()) * 20.0; //scale sine wave by 20.0
  (point, STEELBLUE)
});
draw.polyline()
    .weight(3.0)
    .colored_points(points);
</code></pre>
<p><img src="tutorials/basics/./images/2d-simple-polyline.png" alt="A sine wave polyline drawing" /></p>
<p>As you can see, the power of <code>polyline</code> is the ability to draw a series of lines
connecting and ordered array of points.  With this, you can easily draw a
variety of shapes or lines, so long as you can provide or generate the points
you need to represent that shape.</p>
<p>For example, a circle:</p>
<pre><code>let radius = 150.0;                   // store the radius of the circle we want to make
let points = (0..=360).map(|i| {      // map over an array of integers from 0 to 360 to represent the degrees in a circle

   let radian = deg_to_rad(i as f32); // convert each degree to radians
   let x = radian.sin() * radius;     // get the sine of the radian to find the x-co-ordinate of
                                      // this point of the circle, and multiply it by the radius
   let y = radian.cos() * radius;     // do the same with cosine to find the y co-ordinate
   (pt2(x,y), STEELBLUE)              // construct and return a point object with a color
});
draw.polyline()                       // create a PathStroke Builder object
    .weight(3.0)
    .colored_points(points);          // tell our PathStroke Builder to draw lines connecting our array of points
</code></pre>
<p><img src="tutorials/basics/./images/2d-custom-circle-outline.png" alt="A custom circle" /></p>
<p>A custom drawn circle! ...okay, perhaps this isn't too exciting, given that we
already have an easy way of drawing circles with <code>ellipse</code>.  But with a simple change to the above code we can generate an outline of a
different shape.  Let's try using the <code>step_by</code> function, which allows us to
choose the interval at which we would like to step through a range or other iterator.  So instead
of calling <code>(0..=360).map</code>, we will call <code>(0..=360).step_by(45).map</code>:</p>
<pre><code>let points = (0..=360).step_by(45).map(|i| {
</code></pre>
<p>The rest of our code will remain unchanged.</p>
<p>Because 45 divides into 360 eight times, our code generated 8 points to represent a regular octagon.</p>
<p><img src="tutorials/basics/./images/2d-complete-octogon-outline.png" alt="An octagon outline" /></p>
<p>An octagon!</p>
<p>Try experimenting with different values to pass into <code>step_by</code> and see the
different shapes you can create!</p>
<p>As a side note, you may have noticed that we did not use a <code>color</code> function to set the drawing's
color this time.  Instead, <code>polyline</code> requires that each point be given a color.
This means that you can change the color of the polyline point-by-point.  Try
experimenting with it!</p>
<h2><a class="header" href="#drawing-custom-polygons" id="drawing-custom-polygons">Drawing Custom Polygons</a></h2>
<p>To draw a custom filled-in polygon (and not just an outline), will we use code very similar to our custom circle or
octagon code.  The main difference is that instead of calling <code>polyline</code> to
create a Builder, we call <code>polygon</code>:</p>
<pre><code>let radius = 150.0;
let points = (0..=360).step_by(45).map(|i| {
   let radian = deg_to_rad(i as f32);
   let x = radian.sin() * radius;
   let y = radian.cos() * radius;
   pt2(x,y)
});
draw.polygon()
    .color(STEELBLUE)
    .points(points);
</code></pre>
<p><img src="tutorials/basics/./images/2d-custom-octogon-polygon.png" alt="An octagon" /></p>
<p>Notice how we are again using the <code>color</code> function to set the color of our
polygon, similar to the basic polygon functions covered in the beginning of this
tutorial.</p>
<h2><a class="header" href="#concluding-remarks-1" id="concluding-remarks-1">Concluding Remarks</a></h2>
<p>In this tutorial, we learned about most basic 2D drawing functions with nannou.</p>
<p>You can view the documentation for the different <code>Drawing</code> objects these return here:</p>
<ul>
<li><a href="https://docs.rs/nannou/latest/nannou/draw/primitive/ellipse/struct.Ellipse.html">Ellipse</a></li>
<li><a href="https://docs.rs/nannou/latest/nannou/draw/primitive/rect/struct.Rect.html">Rect</a></li>
<li><a href="https://docs.rs/nannou/latest/nannou/draw/primitive/quad/struct.Quad.html">Quad</a></li>
<li><a href="https://docs.rs/nannou/latest/nannou/draw/primitive/tri/struct.Tri.html">Tri</a></li>
<li><a href="https://docs.rs/nannou/latest/nannou/draw/primitive/path/type.PathStroke.html">Polyline (or PathStroke)</a></li>
<li><a href="https://docs.rs/nannou/latest/nannou/draw/primitive/polygon/struct.Polygon.html">Polygon</a></li>
</ul>
<p>These links provide more information about other functions you can use to change your drawings in a variety of ways.</p>
<p>You have now learned about some of the most commonly used functions for 2D drawing with
nannou. Of course, this is just scratching the surface of ways in which you can generate
shapes or polygons with nannou, but it should serve as a solid starting point in
creating your own drawings.</p>
<p>Happy coding!</p>
<h1><a class="header" href="#developer-reference" id="developer-reference">Developer Reference</a></h1>
<p><strong>TODO:</strong> A guide to the architecture of Nannou's internals to help onboard new
developers. Describes the layout of modules, how to navigate the reference, the
scope of the main nannou crate i.e. the kinds of work that should go inside the
main repo and the kinds that might be better off in separate repos, etc.</p>
<h1><a class="header" href="#api-reference" id="api-reference">API Reference</a></h1>
<p>Eventually, we would like to host the API documentation here. For now, you can
find it at <a href="https://docs.rs/nannou">docs.rs/nannou</a>.</p>
<h1><a class="header" href="#showcases" id="showcases">Showcases</a></h1>
<p><strong>TODO:</strong> A collection of work made with nannou, perhaps ordered from most
recent to the past. Users could do a PR to have their own nannou projects
published.</p>
<ul>
<li><a href="https://github.com/mitchmindtree/nannou-sketches">sketches by mitchmindtree</a></li>
</ul>
<h1><a class="header" href="#contributors" id="contributors">Contributors</a></h1>
<p>This project exists thanks to all the people who contribute.</p>
<p><a href="https://github.com/nannou-org/nannou/graphs/contributors"><img src="https://opencollective.com/nannou/contributors.svg?width=890&button=false" /></a></p>
<h2><a class="header" href="#backers" id="backers">Backers</a></h2>
<p>Thank you to all our backers! 🙏 </p>
<p><a href="https://opencollective.com/nannou#backers" target="_blank"><img src="https://opencollective.com/nannou/backers.svg?width=890"></a></p>
<h2><a class="header" href="#sponsors" id="sponsors">Sponsors</a></h2>
<p>Support this project by becoming a sponsor. Your logo will show up here with a link to your website.</p>
<p><a href="https://opencollective.com/nannou/sponsor/0/website" target="_blank"><img src="https://opencollective.com/nannou/sponsor/0/avatar.svg"></a>
<a href="https://opencollective.com/nannou/sponsor/1/website" target="_blank"><img src="https://opencollective.com/nannou/sponsor/1/avatar.svg"></a>
<a href="https://opencollective.com/nannou/sponsor/2/website" target="_blank"><img src="https://opencollective.com/nannou/sponsor/2/avatar.svg"></a>
<a href="https://opencollective.com/nannou/sponsor/3/website" target="_blank"><img src="https://opencollective.com/nannou/sponsor/3/avatar.svg"></a>
<a href="https://opencollective.com/nannou/sponsor/4/website" target="_blank"><img src="https://opencollective.com/nannou/sponsor/4/avatar.svg"></a>
<a href="https://opencollective.com/nannou/sponsor/5/website" target="_blank"><img src="https://opencollective.com/nannou/sponsor/5/avatar.svg"></a>
<a href="https://opencollective.com/nannou/sponsor/6/website" target="_blank"><img src="https://opencollective.com/nannou/sponsor/6/avatar.svg"></a>
<a href="https://opencollective.com/nannou/sponsor/7/website" target="_blank"><img src="https://opencollective.com/nannou/sponsor/7/avatar.svg"></a>
<a href="https://opencollective.com/nannou/sponsor/8/website" target="_blank"><img src="https://opencollective.com/nannou/sponsor/8/avatar.svg"></a>
<a href="https://opencollective.com/nannou/sponsor/9/website" target="_blank"><img src="https://opencollective.com/nannou/sponsor/9/avatar.svg"></a></p>
<h1><a class="header" href="#contributor-covenant-code-of-conduct" id="contributor-covenant-code-of-conduct">Contributor Covenant Code of Conduct</a></h1>
<h2><a class="header" href="#our-pledge" id="our-pledge">Our Pledge</a></h2>
<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>
<h2><a class="header" href="#conduct" id="conduct">Conduct</a></h2>
<ul>
<li>We are committed to providing a friendly, safe and welcoming environment for all, regardless of level of experience, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, nationality, or other similar characteristic.</li>
<li>Please be kind and courteous. There’s no need to be mean or rude.</li>
<li>Respect that people have differences of opinion and that every design or implementation choice carries a trade-off and numerous costs. There is seldom a right answer.</li>
<li>Please keep unstructured critique to a minimum. If you have solid ideas you want to experiment with, make a fork and see how it works.</li>
<li>We will exclude you from interaction if you insult, demean or harass anyone. That is not welcome behavior. We interpret the term “harassment” as including the definition in the Citizen Code of Conduct; if you have any lack of clarity about what might be included in that concept, please read their definition. In particular, we don’t tolerate behavior that excludes people in socially marginalized groups.</li>
<li>Private harassment is also unacceptable. No matter who you are, if you feel you have been or are being harassed or made uncomfortable by a community member, please contact one of the channel ops or any of the Nannou moderation team immediately. Whether you’re a regular contributor or a newcomer, we care about making this community a safe place for you and we’ve got your back.</li>
<li>Likewise any spamming, trolling, flaming, baiting or other attention-stealing behavior is not welcome.</li>
</ul>
<h2><a class="header" href="#moderation" id="moderation">Moderation</a></h2>
<p>These are the policies for upholding our community’s standards of conduct. If you feel that a thread needs moderation, please contact the <a href="mailto:contact@nannou.cc">Nannou moderation team</a>:</p>
<ol>
<li>Remarks that violate the Nannou standards of conduct, including hateful, hurtful, oppressive, or exclusionary remarks, are not allowed. (Cursing is allowed, but never targeting another user, and never in a hateful manner.)</li>
<li>Remarks that moderators find inappropriate, whether listed in the code of conduct or not, are also not allowed.</li>
<li>Moderators will first respond to such remarks with a warning.</li>
<li>If the warning is unheeded, the user will be “kicked,” i.e., kicked out of the communication channel to cool off.</li>
<li>If the user comes back and continues to make trouble, they will be banned, i.e., indefinitely excluded.</li>
<li>Moderators may choose at their discretion to un-ban the user if it was a first offense and they offer the offended party a genuine apology.</li>
<li>If a moderator bans someone and you think it was unjustified, please take it up with that moderator, or with a different moderator, in private. Complaints about bans in-channel are not allowed.</li>
<li>Moderators are held to a higher standard than other community members. If a moderator creates an inappropriate situation, they should expect less leeway than others.</li>
</ol>
<p>In the Nannou community we strive to go the extra step to look out for each other. Don’t just aim to be technically unimpeachable, try to be your best self. In particular, avoid flirting with offensive or sensitive issues, particularly if they’re off-topic; this all too often leads to unnecessary fights, hurt feelings, and damaged trust; worse, it can drive people away from the community entirely.</p>
<p>And if someone takes issue with something you said or did, resist the urge to be defensive. Just stop doing what it was they complained about and apologize. Even if you feel you were misinterpreted or unfairly accused, chances are good there was something you could’ve communicated better — remember that it’s your responsibility to make your fellow members of the community comfortable. Everyone wants to get along and we are all here first and foremost because we want to talk about cool technology. You will find that people will be eager to assume good intent and forgive as long as you earn their trust.</p>
<h2><a class="header" href="#our-responsibilities" id="our-responsibilities">Our Responsibilities</a></h2>
<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p>
<p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>
<h2><a class="header" href="#scope" id="scope">Scope</a></h2>
<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>
<h2><a class="header" href="#enforcement" id="enforcement">Enforcement</a></h2>
<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at <a href="mailto:contact@nannou.cc"><strong>contact@nannou.cc</strong></a>. The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p>
<p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>
<h2><a class="header" href="#attribution" id="attribution">Attribution</a></h2>
<p>This Code of Conduct is adapted from the <a href="http://contributor-covenant.org">Contributor Covenant</a>, version 1.4, available at <a href="http://contributor-covenant.org/version/1/4/">http://contributor-covenant.org/version/1/4</a> as well as the <a href="http://blog.izs.me/post/30036893703/policy-on-trolling">Node.js Policy on Trolling</a> and the <a href="https://www.rust-lang.org/en-US/conduct.html">Rust Code of Conduct</a> </p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
